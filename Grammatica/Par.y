-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Grammatica.Par
  ( happyError
  , myLexer
  , pProgram
  , pStmt
  , pRExpr
  , pLExpr
  ) where

import Prelude

import qualified Grammatica.Abs
import Grammatica.Lex

}

%name pProgram Program
%name pStmt Stmt
%name pRExpr RExpr
%name pLExpr LExpr
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}

--
-- CORREZIONE DEFINITIVA: Ogni token usa un "as-pattern" per catturare l'intero oggetto
-- Token e passarlo come valore semantico, senza usare '->' che confondeva Happy.
--
%token
  '!'        { tok@(PT _ (TS "!" _))        }
  '!='       { tok@(PT _ (TS "!=" _))       }
  '%'        { tok@(PT _ (TS "%" _))        }
  '&'        { tok@(PT _ (TS "&" _))        }
  '&&'       { tok@(PT _ (TS "&&" _))       }
  '&='       { tok@(PT _ (TS "&=" _))       }
  '('        { tok@(PT _ (TS "(" _))        }
  ')'        { tok@(PT _ (TS ")" _))        }
  '*'        { tok@(PT _ (TS "*" _))        }
  '*='       { tok@(PT _ (TS "*=" _))       }
  '+'        { tok@(PT _ (TS "+" _))        }
  '++'       { tok@(PT _ (TS "++" _))       }
  '+='       { tok@(PT _ (TS "+=" _))       }
  ','        { tok@(PT _ (TS "," _))        }
  '-'        { tok@(PT _ (TS "-" _))        }
  '--'       { tok@(PT _ (TS "--" _))       }
  '-='       { tok@(PT _ (TS "-=" _))       }
  '/'        { tok@(PT _ (TS "/" _))        }
  '/='       { tok@(PT _ (TS "/=" _))       }
  ';'        { tok@(PT _ (TS ";" _))        }
  '<'        { tok@(PT _ (TS "<" _))        }
  '<='       { tok@(PT _ (TS "<=" _))       }
  '='        { tok@(PT _ (TS "=" _))        }
  '=='       { tok@(PT _ (TS "==" _))       }
  '>'        { tok@(PT _ (TS ">" _))        }
  '>='       { tok@(PT _ (TS ">=" _))       }
  '['        { tok@(PT _ (TS "[" _))        }
  ']'        { tok@(PT _ (TS "]" _))        }
  '^'        { tok@(PT _ (TS "^" _))        }
  '^='       { tok@(PT _ (TS "^=" _))       }
  'bool'     { tok@(PT _ (TS "bool" _))     }
  'break'    { tok@(PT _ (TS "break" _))    }
  'char'     { tok@(PT _ (TS "char" _))     }
  'continue' { tok@(PT _ (TS "continue" _)) }
  'do'       { tok@(PT _ (TS "do" _))       }
  'else'     { tok@(PT _ (TS "else" _))     }
  'false'    { tok@(PT _ (TS "false" _))    }
  'float'    { tok@(PT _ (TS "float" _))    }
  'func'     { tok@(PT _ (TS "func" _))     }
  'if'       { tok@(PT _ (TS "if" _))       }
  'int'      { tok@(PT _ (TS "int" _))      }
  'string'   { tok@(PT _ (TS "string" _))   }
  'true'     { tok@(PT _ (TS "true" _))     }
  'var'      { tok@(PT _ (TS "var" _))      }
  'while'    { tok@(PT _ (TS "while" _))    }
  '{'        { tok@(PT _ (TS "{" _))        }
  '|='       { tok@(PT _ (TS "|=" _))       }
  '||'       { tok@(PT _ (TS "||" _))       }
  '}'        { tok@(PT _ (TS "}" _))        }
  L_Ident    { tok@(PT _ (TV _))            }
  L_charac   { tok@(PT _ (TC _))            }
  L_doubl    { tok@(PT _ (TD _))            }
  L_integ    { tok@(PT _ (TI _))            }
  L_quoted   { tok@(PT _ (TL _))            }

%%

Boolean :: { Grammatica.Abs.Positioned Grammatica.Abs.Boolean }
Boolean
  : 'true' { positioned $1 Grammatica.Abs.Boolean_true }
  | 'false' { positioned $1 Grammatica.Abs.Boolean_false }

RExpr :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr
  : RExpr1 { $1 }
  | RExpr '||' RExpr1 { positioned $2 $ Grammatica.Abs.Or $1 $3 }

RExpr1 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr1
  : RExpr2 { $1 }
  | RExpr1 '&&' RExpr2 { positioned $2 $ Grammatica.Abs.And $1 $3 }

RExpr2 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr2
  : RExpr3 { $1 }
  | '!' RExpr3 { positioned $1 $ Grammatica.Abs.Not $2 }

RExpr3 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr3
  : RExpr4 { $1 }
  | RExpr4 '==' RExpr4 { positioned $2 $ Grammatica.Abs.Eq $1 $3 }
  | RExpr4 '!=' RExpr4 { positioned $2 $ Grammatica.Abs.Neq $1 $3 }
  | RExpr4 '<' RExpr4 { positioned $2 $ Grammatica.Abs.Lt $1 $3 }
  | RExpr4 '<=' RExpr4 { positioned $2 $ Grammatica.Abs.LtE $1 $3 }
  | RExpr4 '>' RExpr4 { positioned $2 $ Grammatica.Abs.Gt $1 $3 }
  | RExpr4 '>=' RExpr4 { positioned $2 $ Grammatica.Abs.GtE $1 $3 }

RExpr4 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr4
  : RExpr5 { $1 }
  | RExpr4 '+' RExpr5 { positioned $2 $ Grammatica.Abs.Add $1 $3 }
  | RExpr4 '-' RExpr5 { positioned $2 $ Grammatica.Abs.Sub $1 $3 }

RExpr5 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr5
  : RExpr6 { $1 }
  | RExpr5 '*' RExpr6 { positioned $2 $ Grammatica.Abs.Mul $1 $3 }
  | RExpr5 '/' RExpr6 { positioned $2 $ Grammatica.Abs.Div $1 $3 }
  | RExpr5 '%' RExpr6 { positioned $2 $ Grammatica.Abs.Mod $1 $3 }

RExpr6 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr6
  : RExpr7 { $1 }
  | RExpr7 '^' RExpr6 { positioned $2 $ Grammatica.Abs.Pow $1 $3 }

RExpr7 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr7
  : RExpr8 { $1 }
  | '-' RExpr8 { positioned $1 $ Grammatica.Abs.Neg $2 }
  | '&' LExpr { positioned $1 $ Grammatica.Abs.Ref $2 }

RExpr8 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr8
  : RExpr9 { $1 }
  | FunCall { positionedFrom $1 (Grammatica.Abs.FCall $1) }

RExpr9 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr9
  : RExpr10 { $1 }
  | L_integ { positioned $1 $ Grammatica.Abs.Int $ positioned $1 $ read (getTextFromToken $1) }
  | L_charac { positioned $1 $ Grammatica.Abs.Char $ positioned $1 $ read (getTextFromToken $1) }
  | L_quoted { positioned $1 $ Grammatica.Abs.String $ positioned $1 $ getTextFromToken $1 }
  | L_doubl { positioned $1 $ Grammatica.Abs.Float $ positioned $1 $ read (getTextFromToken $1) }
  | Boolean { positionedFrom $1 $ Grammatica.Abs.Bool $1 }
  | '[' L_integ ']' BasicType '{' ListRExpr '}' {
      positioned $1 $ Grammatica.Abs.GoArrayLit
        (positioned $2 (read (getTextFromToken $2)))
        $4
        $6
    }

RExpr10 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr10 : RExpr11 { $1 }

RExpr11 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr11 : RExpr12 { $1 }

RExpr12 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr12
  : '(' RExpr ')' { $2 }
  | LExpr { positionedFrom $1 (Grammatica.Abs.Lexpr $1) }

FunCall :: { Grammatica.Abs.Positioned Grammatica.Abs.FunCall }
FunCall
  : L_Ident '(' ListRExpr ')' {
      positioned $2 $ Grammatica.Abs.Call
        (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1)))
        $3
    }

ListRExpr :: { [Grammatica.Abs.Positioned Grammatica.Abs.RExpr] }
ListRExpr
  : {- empty -} { [] }
  | RExpr { (:[]) $1 }
  | RExpr ',' ListRExpr { (:) $1 $3 }

LExpr :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr
  : LExpr1 { $1 }
  | '*' RExpr9 { positioned $1 $ Grammatica.Abs.Deref $2 }

LExpr1 :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr1
  : LExpr2 { $1 }
  | '++' LExpr2 { positioned $1 $ Grammatica.Abs.PreInc $2 }
  | '--' LExpr2 { positioned $1 $ Grammatica.Abs.PreDecr $2 }

LExpr2 :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr2
  : LExpr3 { $1 }
  | LExpr3 '++' { positioned $2 $ Grammatica.Abs.PostInc $1 }
  | LExpr3 '--' { positioned $2 $ Grammatica.Abs.PostDecr $1 }
  | BLExpr { positionedFrom $1 (Grammatica.Abs.BasLExpr $1) }

LExpr3 :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr3 : '(' LExpr ')' { $2 }

BLExpr :: { Grammatica.Abs.Positioned Grammatica.Abs.BLExpr }
BLExpr
  : L_Ident '[' RExpr ']' { positioned $2 $ Grammatica.Abs.ArrayEl (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1))) $3 }
  | L_Ident { positioned $1 $ Grammatica.Abs.Id $ positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1)) }

Program :: { Grammatica.Abs.Positioned Grammatica.Abs.Program }
Program : ListDecl { positionedFromList $1 (Grammatica.Abs.Prog $1) }

ListDecl :: { [Grammatica.Abs.Positioned Grammatica.Abs.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl ListDecl { (:) $1 $2 }

Decl :: { Grammatica.Abs.Positioned Grammatica.Abs.Decl }
Decl
  : 'func' L_Ident '(' ListParameter ')' CompStmt {
      positioned $1 $ Grammatica.Abs.Dfun
        (positioned $2 (Grammatica.Abs.Ident (getTextFromToken $2)))
        $4
        $6
    }
  | 'var' VarSpec ';' { positioned $1 $ Grammatica.Abs.DvarGo $2 }

ListParameter :: { [Grammatica.Abs.Positioned Grammatica.Abs.Parameter] }
ListParameter
  : {- empty -} { [] }
  | Parameter { (:[]) $1 }
  | Parameter ',' ListParameter { (:) $1 $3 }

Parameter :: { Grammatica.Abs.Positioned Grammatica.Abs.Parameter }
Parameter
  : 'var' L_Ident TypeSpec {
      positioned $1 $ Grammatica.Abs.Param
        (positioned $2 (Grammatica.Abs.Ident (getTextFromToken $2)))
        $3
    }

VarSpec :: { Grammatica.Abs.Positioned Grammatica.Abs.VarSpec }
VarSpec
  : L_Ident TypeSpec '=' RExpr {
      positioned $3 $ Grammatica.Abs.VarSpecSingleInit
        (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1)))
        $2
        $4
    }
  | L_Ident '=' RExpr {
      positioned $2 $ Grammatica.Abs.VarSpecArrayInit
        (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1)))
        $3
    }
  | L_Ident TypeSpec {
      positioned $1 $ Grammatica.Abs.VarSpecSingleNoInit
        (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1)))
        $2
    }

TypeSpec :: { Grammatica.Abs.Positioned Grammatica.Abs.TypeSpec }
TypeSpec
  : BasicType { positionedFrom $1 $ Grammatica.Abs.BasTyp $1 }
  | CompoundType { positionedFrom $1 $ Grammatica.Abs.CompType $1 }

BasicType :: { Grammatica.Abs.Positioned Grammatica.Abs.BasicType }
BasicType
  : 'bool' { positioned $1 Grammatica.Abs.BasicType_bool }
  | 'char' { positioned $1 Grammatica.Abs.BasicType_char }
  | 'float' { positioned $1 Grammatica.Abs.BasicType_float }
  | 'int' { positioned $1 Grammatica.Abs.BasicType_int }
  | 'string' { positioned $1 Grammatica.Abs.BasicType_string }

CompoundType :: { Grammatica.Abs.Positioned Grammatica.Abs.CompoundType }
CompoundType
  : '[' L_integ ']' TypeSpec { positioned $1 $ Grammatica.Abs.ArrDef (positioned $2 (read (getTextFromToken $2))) $4 }
  | '[' ']' TypeSpec { positioned $1 $ Grammatica.Abs.ArrUnDef $3 }
  | '*' TypeSpec { positioned $1 $ Grammatica.Abs.Pointer $2 }

CompStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.CompStmt }
CompStmt : '{' ListBlockItem '}' { positioned $1 $ Grammatica.Abs.BlockDecl $2 }

ListBlockItem :: { [Grammatica.Abs.Positioned Grammatica.Abs.BlockItem] }
ListBlockItem
  : {- empty -} { [] }
  | BlockItem ListBlockItem { (:) $1 $2 }

BlockItem :: { Grammatica.Abs.Positioned Grammatica.Abs.BlockItem }
BlockItem
  : Decl { positionedFrom $1 (Grammatica.Abs.DeclItem $1) }
  | Stmt { positionedFrom $1 (Grammatica.Abs.StmtItem $1) }

ListStmt :: { [Grammatica.Abs.Positioned Grammatica.Abs.Stmt] }
ListStmt
  : {- empty -} { [] }
  | Stmt ListStmt { (:) $1 $2 }

Stmt :: { Grammatica.Abs.Positioned Grammatica.Abs.Stmt }
Stmt
  : CompStmt { positionedFrom $1 (Grammatica.Abs.Comp $1) }
  | FunCall ';' { positionedFrom $1 (Grammatica.Abs.ProcCall $1) }
  | JumpStmt ';' { positionedFrom $1 (Grammatica.Abs.Jmp $1) }
  | IterStmt { positionedFrom $1 (Grammatica.Abs.Iter $1) }
  | SelectionStmt { positionedFrom $1 (Grammatica.Abs.Sel $1) }
  | LExpr Assignment_op RExpr ';' { positionedFrom $2 (Grammatica.Abs.Assgn $1 $2 $3) }
  | LExpr ';' { positionedFrom $1 (Grammatica.Abs.LExprStmt $1) }
  | 'var' VarSpec ';' { positioned $1 $ Grammatica.Abs.DeclStmt $2 }
  | L_Ident '++' ';' { positioned $2 $ Grammatica.Abs.StmtInc (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1))) }
  | L_Ident '--' ';' { positioned $2 $ Grammatica.Abs.StmtDec (positioned $1 (Grammatica.Abs.Ident (getTextFromToken $1))) }

Assignment_op :: { Grammatica.Abs.Positioned Grammatica.Abs.Assignment_op }
Assignment_op
  : '=' { positioned $1 $ Grammatica.Abs.Assign }
  | '*=' { positioned $1 $ Grammatica.Abs.AssgnMul }
  | '+=' { positioned $1 $ Grammatica.Abs.AssgnAdd }
  | '/=' { positioned $1 $ Grammatica.Abs.AssgnDiv }
  | '-=' { positioned $1 $ Grammatica.Abs.AssgnSub }
  | '^=' { positioned $1 $ Grammatica.Abs.AssgnPow }
  | '&=' { positioned $1 $ Grammatica.Abs.AssgnAnd }
  | '|=' { positioned $1 $ Grammatica.Abs.AssgnOr }

JumpStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.JumpStmt }
JumpStmt
  : 'break' { positioned $1 $ Grammatica.Abs.Break }
  | 'continue' { positioned $1 $ Grammatica.Abs.Continue }

SelectionStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.SelectionStmt }
SelectionStmt
  : 'if' '(' RExpr ')' Stmt {
      positioned $1 $ Grammatica.Abs.IfNoElse $3 $5
    }
  | 'if' '(' RExpr ')' Stmt 'else' Stmt {
      positioned $1 $ Grammatica.Abs.IfElse $3 $5 $7
    }

IterStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.IterStmt }
IterStmt
  : 'while' '(' RExpr ')' Stmt {
      positioned $1 $ Grammatica.Abs.While $3 $5
    }
  | 'do' Stmt 'while' '(' RExpr ')' ';' {
      positioned $1 $ Grammatica.Abs.DoWhile $2 $5
    }

{

-- Helper function to create Positioned values
mkPos :: Token -> Grammatica.Abs.SourcePos
mkPos (PT (Pn _ l c) _) = Grammatica.Abs.SourcePos l c ""

-- Per creare positioned da un Token
positioned :: Token -> a -> Grammatica.Abs.Positioned a
positioned tok x = Grammatica.Abs.Positioned (mkPos tok) x

-- Per creare positioned copiando la posizione da un altro Positioned
positionedFrom :: Grammatica.Abs.Positioned b -> c -> Grammatica.Abs.Positioned c
positionedFrom (Grammatica.Abs.Positioned pos _) x = Grammatica.Abs.Positioned pos x

-- Per creare positioned da una lista non vuota
positionedFromList :: [Grammatica.Abs.Positioned a] -> b -> Grammatica.Abs.Positioned b
positionedFromList [] x = Grammatica.Abs.Positioned (Grammatica.Abs.SourcePos 0 0 "") x
positionedFromList ((Grammatica.Abs.Positioned pos _):_) x = Grammatica.Abs.Positioned pos x

-- Helper function to get the string from a token.
getTextFromToken :: Token -> String
getTextFromToken (PT _ (TS s _)) = s
getTextFromToken (PT _ (TV s))   = s
getTextFromToken (PT _ (TC s))   = s
getTextFromToken (PT _ (TD s))   = s
getTextFromToken (PT _ (TI s))   = s
getTextFromToken (PT _ (TL s))   = s
getTextFromToken token           = prToken token -- Fallback

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}