-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Grammatica.Par
  ( happyError
  , myLexer
  , pProgram
  , pStmt
  , pRExpr
  , pLExpr
  ) where

import Prelude

import qualified Grammatica.Abs
import Grammatica.Lex

}

%name pProgram Program
%name pStmt Stmt
%name pRExpr RExpr
%name pLExpr LExpr
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'        { PT _ (TS _ 1)  }
  '!='       { PT _ (TS _ 2)  }
  '%'        { PT _ (TS _ 3)  }
  '&'        { PT _ (TS _ 4)  }
  '&&'       { PT _ (TS _ 5)  }
  '&='       { PT _ (TS _ 6)  }
  '('        { PT _ (TS _ 7)  }
  ')'        { PT _ (TS _ 8)  }
  '*'        { PT _ (TS _ 9)  }
  '*='       { PT _ (TS _ 10) }
  '+'        { PT _ (TS _ 11) }
  '++'       { PT _ (TS _ 12) }
  '+='       { PT _ (TS _ 13) }
  ','        { PT _ (TS _ 14) }
  '-'        { PT _ (TS _ 15) }
  '--'       { PT _ (TS _ 16) }
  '-='       { PT _ (TS _ 17) }
  '/'        { PT _ (TS _ 18) }
  '/='       { PT _ (TS _ 19) }
  ';'        { PT _ (TS _ 20) }
  '<'        { PT _ (TS _ 21) }
  '<='       { PT _ (TS _ 22) }
  '='        { PT _ (TS _ 23) }
  '=='       { PT _ (TS _ 24) }
  '>'        { PT _ (TS _ 25) }
  '>='       { PT _ (TS _ 26) }
  '['        { PT _ (TS _ 27) }
  ']'        { PT _ (TS _ 28) }
  '^'        { PT _ (TS _ 29) }
  '^='       { PT _ (TS _ 30) }
  'bool'     { PT _ (TS _ 31) }
  'break'    { PT _ (TS _ 32) }
  'char'     { PT _ (TS _ 33) }
  'continue' { PT _ (TS _ 34) }
  'do'       { PT _ (TS _ 35) }
  'else'     { PT _ (TS _ 36) }
  'false'    { PT _ (TS _ 37) }
  'float'    { PT _ (TS _ 38) }
  'func'     { PT _ (TS _ 39) }
  'if'       { PT _ (TS _ 40) }
  'int'      { PT _ (TS _ 41) }
  'string'   { PT _ (TS _ 42) }
  'true'     { PT _ (TS _ 43) }
  'var'      { PT _ (TS _ 44) }
  'while'    { PT _ (TS _ 45) }
  '{'        { PT _ (TS _ 46) }
  '|='       { PT _ (TS _ 47) }
  '||'       { PT _ (TS _ 48) }
  '}'        { PT _ (TS _ 49) }
  L_Ident    { PT _ (TV $$)   }
  L_charac   { PT _ (TC $$)   }
  L_doubl    { PT _ (TD $$)   }
  L_integ    { PT _ (TI $$)   }
  L_quoted   { PT _ (TL $$)   }

%%

Ident :: { Grammatica.Abs.Ident }
Ident  : L_Ident { Grammatica.Abs.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Boolean :: { Grammatica.Abs.Boolean }
Boolean
  : 'true' { Grammatica.Abs.Boolean_true }
  | 'false' { Grammatica.Abs.Boolean_false }

RExpr :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr
  : RExpr1 { $1 } 
  | RExpr '||' RExpr1 { positioned $2 $ Grammatica.Abs.Or $1 $3 }

RExpr1 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr1
  : RExpr2 { $1 } 
  | RExpr1 '&&' RExpr2 { positioned $2 $ Grammatica.Abs.And $1 $3 }

RExpr2 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr2 
  : RExpr3 { $1 } 
  | '!' RExpr3 { positioned $1 $ Grammatica.Abs.Not $2 }

RExpr3 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr3
  : RExpr4 { $1 }
  | RExpr4 '==' RExpr4 { positioned $2 $ Grammatica.Abs.Eq $1 $3 }
  | RExpr4 '!=' RExpr4 { positioned $2 $ Grammatica.Abs.Neq $1 $3 }
  | RExpr4 '<' RExpr4 { positioned $2 $ Grammatica.Abs.Lt $1 $3 }
  | RExpr4 '<=' RExpr4 { positioned $2 $ Grammatica.Abs.LtE $1 $3 }
  | RExpr4 '>' RExpr4 { positioned $2 $ Grammatica.Abs.Gt $1 $3 }
  | RExpr4 '>=' RExpr4 { positioned $2 $ Grammatica.Abs.GtE $1 $3 }

RExpr4 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr4
  : RExpr5 { $1 }
  | RExpr4 '+' RExpr5 { positioned $2 $ Grammatica.Abs.Add $1 $3 }
  | RExpr4 '-' RExpr5 { positioned $2 $ Grammatica.Abs.Sub $1 $3 }

RExpr5 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr5
  : RExpr6 { $1 }
  | RExpr5 '*' RExpr6 { positioned $2 $ Grammatica.Abs.Mul $1 $3 }
  | RExpr5 '/' RExpr6 { positioned $2 $ Grammatica.Abs.Div $1 $3 }
  | RExpr5 '%' RExpr6 { positioned $2 $ Grammatica.Abs.Mod $1 $3 }

RExpr6 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr6
  : RExpr7 { $1 } 
  | RExpr7 '^' RExpr6 { positioned $2 $ Grammatica.Abs.Pow $1 $3 }

RExpr7 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr7
  : RExpr8 { $1 }
  | '-' RExpr8 { positioned $1 $ Grammatica.Abs.Neg $2 }
  | '&' LExpr { positioned $1 $ Grammatica.Abs.Ref $2 }

RExpr8 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr8 
  : RExpr9 { $1 } 
  | FunCall { positionedFrom $1 (Grammatica.Abs.FCall $1) }

RExpr9 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr9
  : RExpr10 { $1 }
  | Integer { positionedLiteral $ Grammatica.Abs.Int $ positionedLiteral $1 }
  | Char { positionedLiteral $ Grammatica.Abs.Char $ positionedLiteral $1 }
  | String { positionedLiteral $ Grammatica.Abs.String $ positionedLiteral $1 }
  | Double { positionedLiteral $ Grammatica.Abs.Float $ positionedLiteral $1 }
  | Boolean { positionedLiteral $ Grammatica.Abs.Bool $ positionedLiteral $1 }
  | '[' Integer ']' BasicType '{' ListRExpr '}' { 
      positioned $1 $ Grammatica.Abs.GoArrayLit 
        (positionedLiteral $2) 
        (positionedLiteral $4) 
        $6 
    }

RExpr10 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr10 : RExpr11 { $1 }

RExpr11 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr11 : RExpr12 { $1 }

RExpr12 :: { Grammatica.Abs.Positioned Grammatica.Abs.RExpr }
RExpr12 
  : '(' RExpr ')' { $2 } 
  | LExpr { positionedFrom $1 (Grammatica.Abs.Lexpr $1) }

FunCall :: { Grammatica.Abs.Positioned Grammatica.Abs.FunCall }
FunCall 
  : Ident '(' ListRExpr ')' { 
      positioned $2 $ Grammatica.Abs.Call 
        (positionedLiteral $1) 
        $3 
    }

ListRExpr :: { [Grammatica.Abs.Positioned Grammatica.Abs.RExpr] }
ListRExpr
  : {- empty -} { [] }
  | RExpr { (:[]) $1 }
  | RExpr ',' ListRExpr { (:) $1 $3 }

LExpr :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr 
  : LExpr1 { $1 } 
  | '*' RExpr9 { positioned $1 $ Grammatica.Abs.Deref $2 }

LExpr1 :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr1
  : LExpr2 { $1 }
  | '++' LExpr2 { positioned $1 $ Grammatica.Abs.PreInc $2 }
  | '--' LExpr2 { positioned $1 $ Grammatica.Abs.PreDecr $2 }

LExpr2 :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr2
  : LExpr3 { $1 }
  | LExpr3 '++' { positioned $2 $ Grammatica.Abs.PostInc $1 }
  | LExpr3 '--' { positioned $2 $ Grammatica.Abs.PostDecr $1 }
  | BLExpr { positionedFrom $1 (Grammatica.Abs.BasLExpr $1) }

LExpr3 :: { Grammatica.Abs.Positioned Grammatica.Abs.LExpr }
LExpr3 : '(' LExpr ')' { $2 }

BLExpr :: { Grammatica.Abs.Positioned Grammatica.Abs.BLExpr }
BLExpr
  : Ident '[' RExpr ']' { positioned $2 $ Grammatica.Abs.ArrayEl (positionedLiteral $1) $3 }
  | Ident { positionedLiteral $ Grammatica.Abs.Id $ positionedLiteral $1 }

Program :: { Grammatica.Abs.Positioned Grammatica.Abs.Program }
Program : ListDecl { positionedFromList $1 (Grammatica.Abs.Prog $1) }

ListDecl :: { [Grammatica.Abs.Positioned Grammatica.Abs.Decl] }
ListDecl 
  : {- empty -} { [] } 
  | Decl ListDecl { (:) $1 $2 }

Decl :: { Grammatica.Abs.Positioned Grammatica.Abs.Decl }
Decl
  : 'func' Ident '(' ListParameter ')' CompStmt { 
      positioned $1 $ Grammatica.Abs.Dfun 
        (positionedLiteral $2) 
        $4 
        $6
    }
  | 'var' VarSpec ';' { positioned $1 $ Grammatica.Abs.DvarGo $2 }

ListParameter :: { [Grammatica.Abs.Positioned Grammatica.Abs.Parameter] }
ListParameter
  : {- empty -} { [] }
  | Parameter { (:[]) $1 }
  | Parameter ',' ListParameter { (:) $1 $3 }

Parameter :: { Grammatica.Abs.Positioned Grammatica.Abs.Parameter }
Parameter 
  : 'var' Ident TypeSpec { 
      positioned $1 $ Grammatica.Abs.Param 
        (positionedLiteral $2) 
        $3 
    }

VarSpec :: { Grammatica.Abs.Positioned Grammatica.Abs.VarSpec }
VarSpec
  : Ident TypeSpec '=' RExpr { 
      positioned $3 $ Grammatica.Abs.VarSpecSingleInit 
        (positionedLiteral $1) 
        $2 
        $4 
    }
  | Ident '=' RExpr { 
      positioned $2 $ Grammatica.Abs.VarSpecArrayInit 
        (positionedLiteral $1) 
        $3 
    }
  | Ident TypeSpec { 
      positionedLiteral $ Grammatica.Abs.VarSpecSingleNoInit 
        (positionedLiteral $1) 
        $2 
    }

TypeSpec :: { Grammatica.Abs.Positioned Grammatica.Abs.TypeSpec }
TypeSpec
  : BasicType { positionedLiteral $ Grammatica.Abs.BasTyp $ positionedLiteral $1 }
  | CompoundType { positionedLiteral $ Grammatica.Abs.CompType $ positionedLiteral $1 }

BasicType :: { Grammatica.Abs.BasicType }
BasicType
  : 'bool' { Grammatica.Abs.BasicType_bool }
  | 'char' { Grammatica.Abs.BasicType_char }
  | 'float' { Grammatica.Abs.BasicType_float }
  | 'int' { Grammatica.Abs.BasicType_int }
  | 'string' { Grammatica.Abs.BasicType_string }

CompoundType :: { Grammatica.Abs.CompoundType }
CompoundType
  : '[' Integer ']' TypeSpec { Grammatica.Abs.ArrDef (positionedLiteral $2) $4 }
  | '[' ']' TypeSpec { Grammatica.Abs.ArrUnDef $3 }
  | '*' TypeSpec { Grammatica.Abs.Pointer $2 }

CompStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.CompStmt }
CompStmt : '{' ListBlockItem '}' { positioned $1 $ Grammatica.Abs.BlockDecl $2 }

ListBlockItem :: { [Grammatica.Abs.Positioned Grammatica.Abs.BlockItem] }
ListBlockItem
  : {- empty -} { [] } 
  | BlockItem ListBlockItem { (:) $1 $2 }

BlockItem :: { Grammatica.Abs.Positioned Grammatica.Abs.BlockItem }
BlockItem
  : Decl { positionedFrom $1 (Grammatica.Abs.DeclItem $1) }
  | Stmt { positionedFrom $1 (Grammatica.Abs.StmtItem $1) }

ListStmt :: { [Grammatica.Abs.Positioned Grammatica.Abs.Stmt] }
ListStmt 
  : {- empty -} { [] } 
  | Stmt ListStmt { (:) $1 $2 }

Stmt :: { Grammatica.Abs.Positioned Grammatica.Abs.Stmt }
Stmt
  : CompStmt { positionedFrom $1 (Grammatica.Abs.Comp $1) }
  | FunCall ';' { positionedFrom $1 (Grammatica.Abs.ProcCall $1) }
  | JumpStmt ';' { positionedFrom $1 (Grammatica.Abs.Jmp $1) }
  | IterStmt { positionedFrom $1 (Grammatica.Abs.Iter $1) }
  | SelectionStmt { positionedFrom $1 (Grammatica.Abs.Sel $1) }
  | LExpr Assignment_op RExpr ';' { positionedFrom $2 (Grammatica.Abs.Assgn $1 $2 $3) }
  | LExpr ';' { positionedFrom $1 (Grammatica.Abs.LExprStmt $1) }
  | 'var' VarSpec ';' { positioned $1 $ Grammatica.Abs.DeclStmt $2 }
  | Ident '++' ';' { positioned $2 $ Grammatica.Abs.StmtInc (positionedLiteral $1) }
  | Ident '--' ';' { positioned $2 $ Grammatica.Abs.StmtDec (positionedLiteral $1) }

Assignment_op :: { Grammatica.Abs.Positioned Grammatica.Abs.Assignment_op }
Assignment_op
  : '=' { positioned $1 $ Grammatica.Abs.Assign }
  | '*=' { positioned $1 $ Grammatica.Abs.AssgnMul }
  | '+=' { positioned $1 $ Grammatica.Abs.AssgnAdd }
  | '/=' { positioned $1 $ Grammatica.Abs.AssgnDiv }
  | '-=' { positioned $1 $ Grammatica.Abs.AssgnSub }
  | '^=' { positioned $1 $ Grammatica.Abs.AssgnPow }
  | '&=' { positioned $1 $ Grammatica.Abs.AssgnAnd }
  | '|=' { positioned $1 $ Grammatica.Abs.AssgnOr }

JumpStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.JumpStmt }
JumpStmt
  : 'break' { positioned $1 $ Grammatica.Abs.Break }
  | 'continue' { positioned $1 $ Grammatica.Abs.Continue }

SelectionStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.SelectionStmt }
SelectionStmt
  : 'if' '(' RExpr ')' Stmt { 
      positioned $1 $ Grammatica.Abs.IfNoElse $3 $5 
    }
  | 'if' '(' RExpr ')' Stmt 'else' Stmt { 
      positioned $1 $ Grammatica.Abs.IfElse $3 $5 $7 
    }

IterStmt :: { Grammatica.Abs.Positioned Grammatica.Abs.IterStmt }
IterStmt
  : 'while' '(' RExpr ')' Stmt { 
      positioned $1 $ Grammatica.Abs.While $3 $5 
    }
  | 'do' Stmt 'while' '(' RExpr ')' ';' { 
      positioned $1 $ Grammatica.Abs.DoWhile $2 $5 
    }

{

-- Helper function to create Positioned values
mkPos :: Token -> Grammatica.Abs.SourcePos
mkPos (PT (Pn _ l c) _) = Grammatica.Abs.SourcePos l c ""

-- Per creare positioned da un Token
positioned :: Token -> a -> Grammatica.Abs.Positioned a
positioned tok x = Grammatica.Abs.Positioned (mkPos tok) x

-- Per creare positioned da un valore letterale (usando posizione dummy)
positionedLiteral :: a -> Grammatica.Abs.Positioned a
positionedLiteral x = Grammatica.Abs.Positioned (Grammatica.Abs.SourcePos 0 0 "") x

-- Per creare positioned copiando la posizione da un altro Positioned
positionedFrom :: Grammatica.Abs.Positioned b -> c -> Grammatica.Abs.Positioned c
positionedFrom (Grammatica.Abs.Positioned pos _) x = Grammatica.Abs.Positioned pos x

-- Per creare positioned da una lista non vuota
positionedFromList :: [Grammatica.Abs.Positioned a] -> b -> Grammatica.Abs.Positioned b
positionedFromList [] x = Grammatica.Abs.Positioned (Grammatica.Abs.SourcePos 0 0 "") x
positionedFromList ((Grammatica.Abs.Positioned pos _):_) x = Grammatica.Abs.Positioned pos x

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}