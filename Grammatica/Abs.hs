-- File generated by the BNF Converter (bnfc 2.9.5).

-- Modifica per AbsGrammatica.hs per includere informazioni di posizione

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Grammatica.Abs where

import Prelude (Char, Double, Integer, String, Int)
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String

-- Informazioni di posizione estratte dai token di BNFC
data SourcePos = SourcePos
  { line :: Int
  , column :: Int
  , filename :: String
  } deriving (C.Eq, C.Ord, C.Show, C.Read)

-- Wrapper per elementi posizionati
data Positioned a = Positioned
  { position :: SourcePos
  , value :: a
  } deriving (C.Eq, C.Ord, C.Show, C.Read)

-- Helper functions
mkPos :: Int -> Int -> String -> SourcePos
mkPos l c f = SourcePos l c f

unPos :: Positioned a -> a
unPos (Positioned _ v) = v

getPos :: Positioned a -> SourcePos
getPos (Positioned p _) = p

-- Mantieni i tipi esistenti ma aggiungi versioni posizionate
data Boolean = Boolean_true | Boolean_false
  deriving (C.Eq, C.Ord, C.Show, C.Read)

-- RExpr con posizioni
data RExpr
    = Or (Positioned RExpr) (Positioned RExpr)
    | And (Positioned RExpr) (Positioned RExpr)
    | Not (Positioned RExpr)
    | Eq (Positioned RExpr) (Positioned RExpr)
    | Neq (Positioned RExpr) (Positioned RExpr)
    | Lt (Positioned RExpr) (Positioned RExpr)
    | LtE (Positioned RExpr) (Positioned RExpr)
    | Gt (Positioned RExpr) (Positioned RExpr)
    | GtE (Positioned RExpr) (Positioned RExpr)
    | Add (Positioned RExpr) (Positioned RExpr)
    | Sub (Positioned RExpr) (Positioned RExpr)
    | Mul (Positioned RExpr) (Positioned RExpr)
    | Div (Positioned RExpr) (Positioned RExpr)
    | Mod (Positioned RExpr) (Positioned RExpr)
    | Pow (Positioned RExpr) (Positioned RExpr)
    | Neg (Positioned RExpr)
    | Ref (Positioned LExpr)
    | FCall (Positioned FunCall)
    | Int (Positioned Integer)
    | Char (Positioned Char)
    | String (Positioned String)
    | Float (Positioned Double)
    | Bool (Positioned Boolean)
    | GoArrayLit (Positioned Integer) (Positioned BasicType) [Positioned RExpr]
    | Lexpr (Positioned LExpr)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunCall = Call (Positioned Ident) [Positioned RExpr]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data LExpr
    = Deref (Positioned RExpr)
    | PreInc (Positioned LExpr)
    | PreDecr (Positioned LExpr)
    | PostInc (Positioned LExpr)
    | PostDecr (Positioned LExpr)
    | BasLExpr (Positioned BLExpr)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BLExpr 
    = ArrayEl (Positioned Ident) (Positioned RExpr) 
    | Id (Positioned Ident)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Program = Prog [Positioned Decl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Decl 
    = Dfun (Positioned Ident) [Positioned Parameter] (Positioned CompStmt) 
    | DvarGo (Positioned VarSpec)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Parameter = Param (Positioned Ident) (Positioned TypeSpec)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data VarSpec
    = VarSpecSingleInit (Positioned Ident) (Positioned TypeSpec) (Positioned RExpr)
    | VarSpecArrayInit (Positioned Ident) (Positioned RExpr)
    | VarSpecSingleNoInit (Positioned Ident) (Positioned TypeSpec)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data TypeSpec 
    = BasTyp (Positioned BasicType) 
    | CompType (Positioned CompoundType)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BasicType
    = BasicType_bool
    | BasicType_char
    | BasicType_float
    | BasicType_int
    | BasicType_string
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data CompoundType
    = ArrDef (Positioned Integer) (Positioned TypeSpec) 
    | ArrUnDef (Positioned TypeSpec) 
    | Pointer (Positioned TypeSpec)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data CompStmt = BlockDecl [Positioned BlockItem]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BlockItem 
    = DeclItem (Positioned Decl) 
    | StmtItem (Positioned Stmt)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Stmt
    = Comp (Positioned CompStmt)
    | ProcCall (Positioned FunCall)
    | Jmp (Positioned JumpStmt)
    | Iter (Positioned IterStmt)
    | Sel (Positioned SelectionStmt)
    | Assgn (Positioned LExpr) (Positioned Assignment_op) (Positioned RExpr)
    | LExprStmt (Positioned LExpr)
    | DeclStmt (Positioned VarSpec)
    | StmtInc (Positioned Ident)
    | StmtDec (Positioned Ident)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Assignment_op
    = Assign
    | AssgnMul
    | AssgnAdd
    | AssgnDiv
    | AssgnSub
    | AssgnPow
    | AssgnAnd
    | AssgnOr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data JumpStmt = Break | Continue
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data SelectionStmt 
    = IfNoElse (Positioned RExpr) (Positioned Stmt) 
    | IfElse (Positioned RExpr) (Positioned Stmt) (Positioned Stmt)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data IterStmt 
    = While (Positioned RExpr) (Positioned Stmt) 
    | DoWhile (Positioned Stmt) (Positioned RExpr)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)