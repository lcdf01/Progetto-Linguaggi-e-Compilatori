-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParGrammatica
  ( happyError
  , myLexer
  , pProgram
  , pStmt
  , pRExpr
  , pLExpr
  ) where

import Prelude

import qualified AbsGrammatica
import LexGrammatica

}

%name pProgram Program
%name pStmt Stmt
%name pRExpr RExpr
%name pLExpr LExpr
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'        { PT _ (TS _ 1)  }
  '!='       { PT _ (TS _ 2)  }
  '%'        { PT _ (TS _ 3)  }
  '&'        { PT _ (TS _ 4)  }
  '&&'       { PT _ (TS _ 5)  }
  '&='       { PT _ (TS _ 6)  }
  '('        { PT _ (TS _ 7)  }
  ')'        { PT _ (TS _ 8)  }
  '*'        { PT _ (TS _ 9)  }
  '*='       { PT _ (TS _ 10) }
  '+'        { PT _ (TS _ 11) }
  '++'       { PT _ (TS _ 12) }
  '+='       { PT _ (TS _ 13) }
  ','        { PT _ (TS _ 14) }
  '-'        { PT _ (TS _ 15) }
  '--'       { PT _ (TS _ 16) }
  '-='       { PT _ (TS _ 17) }
  '/'        { PT _ (TS _ 18) }
  '/='       { PT _ (TS _ 19) }
  ';'        { PT _ (TS _ 20) }
  '<'        { PT _ (TS _ 21) }
  '<='       { PT _ (TS _ 22) }
  '='        { PT _ (TS _ 23) }
  '=='       { PT _ (TS _ 24) }
  '>'        { PT _ (TS _ 25) }
  '>='       { PT _ (TS _ 26) }
  '['        { PT _ (TS _ 27) }
  ']'        { PT _ (TS _ 28) }
  '^'        { PT _ (TS _ 29) }
  '^='       { PT _ (TS _ 30) }
  'bool'     { PT _ (TS _ 31) }
  'break'    { PT _ (TS _ 32) }
  'char'     { PT _ (TS _ 33) }
  'continue' { PT _ (TS _ 34) }
  'do'       { PT _ (TS _ 35) }
  'else'     { PT _ (TS _ 36) }
  'false'    { PT _ (TS _ 37) }
  'float'    { PT _ (TS _ 38) }
  'func'     { PT _ (TS _ 39) }
  'if'       { PT _ (TS _ 40) }
  'int'      { PT _ (TS _ 41) }
  'string'   { PT _ (TS _ 42) }
  'true'     { PT _ (TS _ 43) }
  'var'      { PT _ (TS _ 44) }
  'while'    { PT _ (TS _ 45) }
  '{'        { PT _ (TS _ 46) }
  '|='       { PT _ (TS _ 47) }
  '||'       { PT _ (TS _ 48) }
  '}'        { PT _ (TS _ 49) }
  L_Ident    { PT _ (TV $$)   }
  L_charac   { PT _ (TC $$)   }
  L_doubl    { PT _ (TD $$)   }
  L_integ    { PT _ (TI $$)   }
  L_quoted   { PT _ (TL $$)   }

%%

Ident :: { AbsGrammatica.Ident }
Ident  : L_Ident { AbsGrammatica.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Boolean :: { AbsGrammatica.Boolean }
Boolean
  : 'true' { AbsGrammatica.Boolean_true }
  | 'false' { AbsGrammatica.Boolean_false }

RExpr :: { AbsGrammatica.RExpr }
RExpr
  : RExpr1 { $1 } | RExpr '||' RExpr1 { AbsGrammatica.Or $1 $3 }

RExpr1 :: { AbsGrammatica.RExpr }
RExpr1
  : RExpr2 { $1 } | RExpr1 '&&' RExpr2 { AbsGrammatica.And $1 $3 }

RExpr2 :: { AbsGrammatica.RExpr }
RExpr2 : RExpr3 { $1 } | '!' RExpr3 { AbsGrammatica.Not $2 }

RExpr3 :: { AbsGrammatica.RExpr }
RExpr3
  : RExpr4 { $1 }
  | RExpr4 '==' RExpr4 { AbsGrammatica.Eq $1 $3 }
  | RExpr4 '!=' RExpr4 { AbsGrammatica.Neq $1 $3 }
  | RExpr4 '<' RExpr4 { AbsGrammatica.Lt $1 $3 }
  | RExpr4 '<=' RExpr4 { AbsGrammatica.LtE $1 $3 }
  | RExpr4 '>' RExpr4 { AbsGrammatica.Gt $1 $3 }
  | RExpr4 '>=' RExpr4 { AbsGrammatica.GtE $1 $3 }

RExpr4 :: { AbsGrammatica.RExpr }
RExpr4
  : RExpr5 { $1 }
  | RExpr4 '+' RExpr5 { AbsGrammatica.Add $1 $3 }
  | RExpr4 '-' RExpr5 { AbsGrammatica.Sub $1 $3 }

RExpr5 :: { AbsGrammatica.RExpr }
RExpr5
  : RExpr6 { $1 }
  | RExpr5 '*' RExpr6 { AbsGrammatica.Mul $1 $3 }
  | RExpr5 '/' RExpr6 { AbsGrammatica.Div $1 $3 }
  | RExpr5 '%' RExpr6 { AbsGrammatica.Mod $1 $3 }

RExpr6 :: { AbsGrammatica.RExpr }
RExpr6
  : RExpr7 { $1 } | RExpr7 '^' RExpr6 { AbsGrammatica.Pow $1 $3 }

RExpr7 :: { AbsGrammatica.RExpr }
RExpr7
  : RExpr8 { $1 }
  | '-' RExpr8 { AbsGrammatica.Neg $2 }
  | '&' LExpr { AbsGrammatica.Ref $2 }

RExpr8 :: { AbsGrammatica.RExpr }
RExpr8 : RExpr9 { $1 } | FunCall { AbsGrammatica.FCall $1 }

RExpr9 :: { AbsGrammatica.RExpr }
RExpr9
  : RExpr10 { $1 }
  | Integer { AbsGrammatica.Int $1 }
  | Char { AbsGrammatica.Char $1 }
  | String { AbsGrammatica.String $1 }
  | Double { AbsGrammatica.Float $1 }
  | Boolean { AbsGrammatica.Bool $1 }
  | '[' Integer ']' BasicType '{' ListRExpr '}' { AbsGrammatica.GoArrayLit $2 $4 $6 }

RExpr10 :: { AbsGrammatica.RExpr }
RExpr10 : RExpr11 { $1 }

RExpr11 :: { AbsGrammatica.RExpr }
RExpr11 : RExpr12 { $1 }

RExpr12 :: { AbsGrammatica.RExpr }
RExpr12 : '(' RExpr ')' { $2 } | LExpr { AbsGrammatica.Lexpr $1 }

FunCall :: { AbsGrammatica.FunCall }
FunCall : Ident '(' ListRExpr ')' { AbsGrammatica.Call $1 $3 }

ListRExpr :: { [AbsGrammatica.RExpr] }
ListRExpr
  : {- empty -} { [] }
  | RExpr { (:[]) $1 }
  | RExpr ',' ListRExpr { (:) $1 $3 }

LExpr :: { AbsGrammatica.LExpr }
LExpr : LExpr1 { $1 } | '*' RExpr9 { AbsGrammatica.Deref $2 }

LExpr1 :: { AbsGrammatica.LExpr }
LExpr1
  : LExpr2 { $1 }
  | '++' LExpr2 { AbsGrammatica.PreInc $2 }
  | '--' LExpr2 { AbsGrammatica.PreDecr $2 }

LExpr2 :: { AbsGrammatica.LExpr }
LExpr2
  : LExpr3 { $1 }
  | LExpr3 '++' { AbsGrammatica.PostInc $1 }
  | LExpr3 '--' { AbsGrammatica.PostDecr $1 }
  | BLExpr { AbsGrammatica.BasLExpr $1 }

LExpr3 :: { AbsGrammatica.LExpr }
LExpr3 : '(' LExpr ')' { $2 }

BLExpr :: { AbsGrammatica.BLExpr }
BLExpr
  : Ident '[' RExpr ']' { AbsGrammatica.ArrayEl $1 $3 }
  | Ident { AbsGrammatica.Id $1 }

Program :: { AbsGrammatica.Program }
Program : ListDecl { AbsGrammatica.Prog $1 }

ListDecl :: { [AbsGrammatica.Decl] }
ListDecl : {- empty -} { [] } | Decl ListDecl { (:) $1 $2 }

Decl :: { AbsGrammatica.Decl }
Decl
  : 'func' Ident '(' ListParameter ')' CompStmt { AbsGrammatica.Dfun $2 $4 $6 }
  | 'var' VarSpec ';' { AbsGrammatica.DvarGo $2 }

ListParameter :: { [AbsGrammatica.Parameter] }
ListParameter
  : {- empty -} { [] }
  | Parameter { (:[]) $1 }
  | Parameter ',' ListParameter { (:) $1 $3 }

Parameter :: { AbsGrammatica.Parameter }
Parameter : 'var' Ident TypeSpec { AbsGrammatica.Param $2 $3 }

VarSpec :: { AbsGrammatica.VarSpec }
VarSpec
  : Ident TypeSpec '=' RExpr { AbsGrammatica.VarSpecSingleInit $1 $2 $4 }
  | Ident '=' RExpr { AbsGrammatica.VarSpecArrayInit $1 $3 }
  | Ident TypeSpec { AbsGrammatica.VarSpecSingleNoInit $1 $2 }

TypeSpec :: { AbsGrammatica.TypeSpec }
TypeSpec
  : BasicType { AbsGrammatica.BasTyp $1 }
  | CompoundType { AbsGrammatica.CompType $1 }

BasicType :: { AbsGrammatica.BasicType }
BasicType
  : 'bool' { AbsGrammatica.BasicType_bool }
  | 'char' { AbsGrammatica.BasicType_char }
  | 'float' { AbsGrammatica.BasicType_float }
  | 'int' { AbsGrammatica.BasicType_int }
  | 'string' { AbsGrammatica.BasicType_string }

CompoundType :: { AbsGrammatica.CompoundType }
CompoundType
  : '[' Integer ']' TypeSpec { AbsGrammatica.ArrDef $2 $4 }
  | '[' ']' TypeSpec { AbsGrammatica.ArrUnDef $3 }
  | '*' TypeSpec { AbsGrammatica.Pointer $2 }

CompStmt :: { AbsGrammatica.CompStmt }
CompStmt : '{' ListBlockItem '}' { AbsGrammatica.BlockDecl $2 }

ListBlockItem :: { [AbsGrammatica.BlockItem] }
ListBlockItem
  : {- empty -} { [] } | BlockItem ListBlockItem { (:) $1 $2 }

BlockItem :: { AbsGrammatica.BlockItem }
BlockItem
  : Decl { AbsGrammatica.DeclItem $1 }
  | Stmt { AbsGrammatica.StmtItem $1 }

ListStmt :: { [AbsGrammatica.Stmt] }
ListStmt : {- empty -} { [] } | Stmt ListStmt { (:) $1 $2 }

Stmt :: { AbsGrammatica.Stmt }
Stmt
  : CompStmt { AbsGrammatica.Comp $1 }
  | FunCall ';' { AbsGrammatica.ProcCall $1 }
  | JumpStmt ';' { AbsGrammatica.Jmp $1 }
  | IterStmt { AbsGrammatica.Iter $1 }
  | SelectionStmt { AbsGrammatica.Sel $1 }
  | LExpr Assignment_op RExpr ';' { AbsGrammatica.Assgn $1 $2 $3 }
  | LExpr ';' { AbsGrammatica.LExprStmt $1 }
  | 'var' VarSpec ';' { AbsGrammatica.DeclStmt $2 }
  | Ident '++' ';' { AbsGrammatica.StmtInc $1 }
  | Ident '--' ';' { AbsGrammatica.StmtDec $1 }

Assignment_op :: { AbsGrammatica.Assignment_op }
Assignment_op
  : '=' { AbsGrammatica.Assign }
  | '*=' { AbsGrammatica.AssgnMul }
  | '+=' { AbsGrammatica.AssgnAdd }
  | '/=' { AbsGrammatica.AssgnDiv }
  | '-=' { AbsGrammatica.AssgnSub }
  | '^=' { AbsGrammatica.AssgnPow }
  | '&=' { AbsGrammatica.AssgnAnd }
  | '|=' { AbsGrammatica.AssgnOr }

JumpStmt :: { AbsGrammatica.JumpStmt }
JumpStmt
  : 'break' { AbsGrammatica.Break }
  | 'continue' { AbsGrammatica.Continue }

SelectionStmt :: { AbsGrammatica.SelectionStmt }
SelectionStmt
  : 'if' '(' RExpr ')' Stmt { AbsGrammatica.IfNoElse $3 $5 }
  | 'if' '(' RExpr ')' Stmt 'else' Stmt { AbsGrammatica.IfElse $3 $5 $7 }

IterStmt :: { AbsGrammatica.IterStmt }
IterStmt
  : 'while' '(' RExpr ')' Stmt { AbsGrammatica.While $3 $5 }
  | 'do' Stmt 'while' '(' RExpr ')' ';' { AbsGrammatica.DoWhile $2 $5 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

